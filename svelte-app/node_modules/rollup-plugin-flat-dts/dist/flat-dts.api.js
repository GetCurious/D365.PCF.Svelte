import ts from 'typescript';
import { SourceMapConsumer, SourceMapGenerator } from 'source-map';
import path, { resolve, dirname } from 'node:path';
import { promises } from 'node:fs';
import isGlob from 'is-glob';
import micromatch from 'micromatch';
import process from 'node:process';
import { URL, pathToFileURL } from 'node:url';

class DtsSetup {
    constructor(dtsOptions) {
        this.dtsOptions = dtsOptions;
        const { compilerOptions, files, errors } = parseDtsOptions(dtsOptions);
        this.compilerOptions = compilerOptions;
        this.files = files;
        this.errors = errors;
        this.scriptTarget = detectScriptTarget(compilerOptions);
        this.eol = detectEOL(compilerOptions);
    }
    sourceURL(path) {
        return new URL(path, this.root());
    }
    root() {
        return pathToFileURL('./');
    }
    relativePath(path) {
        const cwd = this.root();
        const { href: cwdHref } = cwd;
        const { href } = new URL(path, cwd);
        if (!href.startsWith(cwdHref)) {
            return path;
        }
        return href.slice(cwdHref.length);
    }
    basename(path) {
        const idx = path.lastIndexOf('/');
        return idx < 0 ? path : path.slice(idx + 1);
    }
    pathToRoot(path) {
        const cwd = this.root();
        const { href: cwdHref } = cwd;
        const { href } = new URL(path, cwd);
        if (!href.startsWith(cwdHref)) {
            return path;
        }
        let relative = href.slice(cwdHref.length);
        let result = '';
        for (;;) {
            const idx = relative.lastIndexOf('/');
            if (idx < 0) {
                break;
            }
            if (result) {
                result += '/..';
            }
            else {
                result = '..';
            }
            relative = relative.slice(0, idx);
        }
        return result;
    }
}
function parseDtsOptions(dtsOptions) {
    const { tsconfig = 'tsconfig.json', file: outFile = 'index.d.ts' } = dtsOptions;
    let { compilerOptions = {} } = dtsOptions;
    compilerOptions = {
        ...compilerOptions,
        ...MANDATORY_COMPILER_OPTIONS,
        outDir: undefined,
        outFile,
    };
    let dirName;
    let tsconfigFile;
    let tsconfigJson;
    if (typeof tsconfig !== 'string') {
        dirName = process.cwd();
        tsconfigJson = tsconfig;
    }
    else {
        dirName = path.dirname(tsconfig);
        tsconfigFile = path.basename(tsconfig);
        const configPath = ts.findConfigFile(dirName, ts.sys.fileExists, tsconfig);
        if (!configPath) {
            return {
                compilerOptions: patchCompilerOptions(compilerOptions),
                files: [],
                errors: [],
            };
        }
        dirName = path.dirname(configPath);
        const { config, error, } = ts.readConfigFile(configPath, ts.sys.readFile);
        if (error) {
            return {
                compilerOptions: patchCompilerOptions(compilerOptions),
                files: [],
                errors: [error],
            };
        }
        tsconfigJson = config;
    }
    const { options, errors, fileNames: files, } = ts.parseJsonConfigFileContent(tsconfigJson, ts.sys, dirName, undefined, tsconfigFile);
    return {
        compilerOptions: patchCompilerOptions({
            ...options,
            ...compilerOptions,
        }),
        files,
        errors,
    };
}
function patchCompilerOptions(compilerOptions) {
    const { moduleResolution } = compilerOptions;
    if (moduleResolution == null
        || moduleResolution === ts.ModuleResolutionKind.Node16
        || moduleResolution === ts.ModuleResolutionKind.NodeNext) {
        // SystemJS does not support `Node16` and `NodeNext` resolutions
        compilerOptions = {
            ...compilerOptions,
            moduleResolution: ts.ModuleResolutionKind.Node10,
        };
    }
    return compilerOptions;
}
const MANDATORY_COMPILER_OPTIONS = {
    // Avoid extra work
    checkJs: false,
    // Ensure ".d.ts" modules are generated
    declaration: true,
    // Prevent output to declaration directory
    declarationDir: undefined,
    // Skip ".js" generation
    emitDeclarationOnly: true,
    // Single file emission is impossible with this flag set
    isolatedModules: false,
    // Generate single file
    // `System`, in contrast to `None`, permits the use of `import.meta`
    module: ts.ModuleKind.System,
    // Always emit
    noEmit: false,
    // Skip code generation when error occurs
    noEmitOnError: true,
    // SystemJS does not support JSON module imports
    resolveJsonModule: false,
    // Ignore errors in library type definitions
    skipLibCheck: true,
    // Always strip internal exports
    stripInternal: true,
    // Unsupported by SystemJS
    verbatimModuleSyntax: false,
};
function detectScriptTarget(compilerOptions) {
    let { target } = compilerOptions;
    if (!target) {
        // Set target to latest if absent
        compilerOptions.target = target = ts.ScriptTarget.Latest;
    }
    return target;
}
function detectEOL({ newLine }) {
    switch (newLine) {
        case ts.NewLineKind.LineFeed:
            return '\n';
        case ts.NewLineKind.CarriageReturnLineFeed:
            return '\r\n';
        default:
            return ts.sys.newLine;
    }
}

class DtsSourceMap {
    static async create(path, content, setup) {
        return new DtsSourceMap(await new SourceMapConsumer(content, setup.sourceURL(path).href), setup);
    }
    constructor(map, setup) {
        this.map = map;
        this.setup = setup;
    }
    originalRange(node, source) {
        if (!(node.pos >= 0) || !(node.end >= 0)) {
            return;
        }
        const startPos = node.getStart(source);
        const endPos = node.getEnd();
        if (startPos < 0 || endPos < 0) {
            return;
        }
        const srcStart = this._sourceLocation(source, startPos);
        if (!srcStart) {
            return;
        }
        const srcEnd = this._sourceLocation(source, endPos);
        if (!srcEnd) {
            return;
        }
        return [srcStart, srcEnd];
    }
    destroy() {
        this.map.destroy();
    }
    _sourceLocation(sourceFile, pos) {
        if (pos < 0) {
            return;
        }
        const location = sourceFile.getLineAndCharacterOfPosition(pos);
        const { source, line, column } = this.map.originalPositionFor({
            line: location.line + 1,
            column: location.character,
        });
        if (source == null || line == null || column == null) {
            return;
        }
        return {
            source: this.setup.relativePath(source),
            line: line - 1,
            col: column,
        };
    }
}

class DtsSource {
    static async create(sources, setup) {
        let source;
        let sourceMap;
        for (const { path, content } of sources) {
            if (path.endsWith('.d.ts')) {
                source = ts.createSourceFile(path, content, setup.scriptTarget, true);
            }
            else if (path.endsWith('.d.ts.map')) {
                sourceMap = { path, content };
            }
        }
        return (source
            && new DtsSource(source, sourceMap && (await DtsSourceMap.create(sourceMap.path, sourceMap.content, setup)), setup));
    }
    constructor(source, map, setup) {
        this.source = source;
        this.map = map;
        this.setup = setup;
    }
    destroy() {
        var _a;
        (_a = this.map) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    hasMap() {
        return !!this.map;
    }
}

const FORMAT_HOST = {
    getCurrentDirectory: () => ts.sys.getCurrentDirectory(),
    getNewLine: () => ts.sys.newLine,
    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? f => f : f => f.toLowerCase(),
};
function formatDiagnostics() {
    return this.diagnostics.length
        ? ts.formatDiagnosticsWithColorAndContext(this.diagnostics, FORMAT_HOST)
        : '';
}
function emptyFlatDts(diagnostics) {
    return {
        files: [],
        diagnostics,
        formatDiagnostics,
        writeOut() {
            return Promise.reject(new Error('Failed to emit type definitions'));
        },
    };
}
function createFlatDts(files, diagnostics = []) {
    return {
        files,
        diagnostics,
        formatDiagnostics,
        writeOut(rootDir) {
            const filePath = rootDir != null ? ({ path }) => resolve(rootDir, path) : ({ path }) => path;
            return Promise.all(files.map(file => file.writeOut(filePath(file)))).then(() => void 0);
        },
    };
}

class DtsPrinter {
    constructor(source) {
        this.source = source;
        this._out = '';
        this._printer = ts.createPrinter({
            newLine: source.setup.compilerOptions.newLine,
        });
    }
    print(node) {
        this.text(this._printer.printNode(ts.EmitHint.Unspecified, node, this.source.source));
        return this;
    }
    text(text) {
        this._out += text;
        return this;
    }
    nl() {
        return this.text(this.source.setup.eol);
    }
    createFile(path, content = this._out) {
        return {
            path,
            content,
            async writeOut(filePath = path) {
                await promises.mkdir(dirname(filePath), { recursive: true });
                return promises.writeFile(filePath, content);
            },
        };
    }
}

class SimpleDtsPrinter extends DtsPrinter {
    toFiles(name) {
        return [this.createFile(name)];
    }
}

class DtsNodeChildren extends Set {
    constructor(node) {
        super();
        ts.forEachChild(node, child => {
            this.add(child);
        });
    }
}

class DtsMapper {
    constructor(_source, dtsFile) {
        this._source = _source;
        this._line = [];
        const { setup } = _source;
        // Re-parse just generated `.d.ts`.
        this._genDts = ts.createSourceFile(dtsFile.path, dtsFile.content, setup.scriptTarget, false, ts.ScriptKind.TS);
        this._generator = new SourceMapGenerator({
            sourceRoot: setup.pathToRoot(dtsFile.path),
            file: setup.basename(dtsFile.path),
        });
    }
    map(orgNodes) {
        this._mapNodes(orgNodes, this._genDts.statements);
        this._endLine();
        return this._generator.toString();
    }
    _mapNodes(orgNodes, genNodes) {
        // Assume the re-parsed AST has the same structure as an original one.
        const orgIt = orgNodes[Symbol.iterator]();
        const genIt = genNodes[Symbol.iterator]();
        for (;;) {
            const orgNext = orgIt.next();
            const genNext = genIt.next();
            if (orgNext.done || genNext.done) {
                break;
            }
            this._mapNode(orgNext.value, genNext.value);
        }
    }
    _mapNode(orgNode, genNode) {
        const orgRange = this._source.map.originalRange(orgNode, this._source.source);
        const genStartPos = genNode.getStart(this._genDts);
        if (!orgRange || genStartPos < 0) {
            this._mapChildren(orgNode, genNode);
            return;
        }
        const [orgStart, orgEnd] = orgRange;
        const genStart = this._genDts.getLineAndCharacterOfPosition(genStartPos);
        this._addMapping({
            generated: { line: genStart.line + 1, column: genStart.character },
            original: { line: orgStart.line + 1, column: orgStart.col },
            source: orgStart.source,
        });
        this._mapChildren(orgNode, genNode);
        const genEnd = this._genDts.getLineAndCharacterOfPosition(genNode.getEnd());
        this._addMapping({
            generated: { line: genEnd.line + 1, column: genEnd.character },
            original: { line: orgEnd.line + 1, column: orgEnd.col },
            source: orgEnd.source,
        });
    }
    _mapChildren(orgNode, genNode) {
        this._mapNodes(new DtsNodeChildren(orgNode), new DtsNodeChildren(genNode));
    }
    _addMapping(mapping) {
        const [prev] = this._line;
        if (prev
            && prev.source === mapping.source
            && prev.generated.line === mapping.generated.line
            && prev.original.line === mapping.original.line) {
            // Mapping from and to the same line
            this._line.push(mapping);
            return;
        }
        this._endLine();
        this._line.length = 0;
        this._line.push(mapping);
    }
    _endLine() {
        // Sort line mappings by column number
        this._line.sort(compareMappingColumns);
        const lastIdx = this._line.length - 1;
        this._line.forEach((mapping, i) => {
            if (i && i < lastIdx) {
                // Always record the first and the last mapping
                const prev = this._line[i - 1];
                const genOffset = mapping.generated.column - prev.generated.column;
                if (!genOffset) {
                    // No need to record the same mapping twice.
                    return;
                }
                /*
                // Disabled. It seems that spanning subsequent segments breaks IDE navigation.
        
                const orgOffset = mapping.original.column - prev.original.column;
        
                if (genOffset === orgOffset) {
                  // The column offset remained the same.
                  // Span with the previous mapping segment.
                  return;
                }
                */
            }
            this._generator.addMapping(mapping);
        });
    }
}
function compareMappingColumns({ generated: { column: col1 } }, { generated: { column: col2 } }) {
    return col1 - col2;
}

class SourceMapDtsPrinter extends DtsPrinter {
    constructor() {
        super(...arguments);
        this._nodes = [];
    }
    print(node) {
        this._nodes.push(node);
        return super.print(node);
    }
    toFiles(name) {
        const dts = this.createFile(name);
        const sourceMap = this._createSourceMapFile(dts);
        const { setup } = this.source;
        return [
            this.createFile(dts.path, `${dts.content}//# sourceMappingURL=${setup.basename(sourceMap.path)}${setup.eol}`),
            sourceMap,
        ];
    }
    _createSourceMapFile(dtsFile) {
        return this.createFile(`${dtsFile.path}.map`, new DtsMapper(this.source, dtsFile).map(this._nodes).toString());
    }
}

class DtsContent {
    constructor(source, module) {
        this.source = source;
        this.module = module;
        this._refs = new Set();
        this._statements = [];
    }
    refer(refs) {
        if (refs) {
            refs.forEach(ref => this._refs.add(ref));
        }
        return this;
    }
    append(statement) {
        this._statements.push(statement);
    }
    toFiles() {
        const printer = this.source.hasMap()
            ? new SourceMapDtsPrinter(this.source)
            : new SimpleDtsPrinter(this.source);
        this.module.prelude(printer);
        this._prelude(printer);
        this._statements.forEach((statement, i) => {
            if (i) {
                printer.nl();
            }
            printer.print(statement).nl();
        });
        return printer.toFiles(this.module.file);
    }
    _prelude(printer) {
        if (this.module.refs) {
            for (const ref of this._refs) {
                const path = this.module.pathTo(ref);
                if (path) {
                    // No need to refer itself.
                    printer.text(`/// <reference path="${path}" />`).nl();
                }
            }
        }
    }
}

class DtsMeta {
    constructor(source) {
        const declaredModules = new Set();
        for (const statement of source.statements) {
            if (statement.kind === ts.SyntaxKind.ModuleDeclaration) {
                const { name } = statement;
                if (!ts.isMemberName(name)) {
                    declaredModules.add(name.text);
                }
            }
        }
        this._declaredModules = declaredModules;
    }
    isModuleDeclared(name) {
        return this._declaredModules.has(name);
    }
}

const noReferredLibs = /*#__PURE__*/ new Set();
class ModuleInfo {
    static async main(source) {
        const { source: { fileName: file }, setup: { dtsOptions: { moduleName = await packageName(), lib, refs = true }, }, } = source;
        return new ModuleInfo(source, moduleName, {
            file,
            libs: referredLibs(source, lib),
            refs,
        });
    }
    static external(source, name) {
        return new ModuleInfo(source, name, 'external');
    }
    static internal(source, name) {
        return new ModuleInfo(source, name, 'internal');
    }
    constructor(source, declareAs, kind) {
        this.source = source;
        this.declareAs = declareAs;
        if (typeof kind === 'string') {
            this.isExternal = kind === 'external';
            this.isInternal = !this.isExternal;
            this.file = undefined;
            this.refs = false;
            this._libs = noReferredLibs;
        }
        else {
            this.isExternal = false;
            this.isInternal = false;
            this.file = kind.file;
            this.refs = kind.refs;
            this._libs = kind.libs;
        }
    }
    prelude(printer) {
        for (const lib of this._libs) {
            printer.text(`/// <reference lib="${lib}" />`).nl();
        }
    }
    nested(name, decl) {
        var _a, _b;
        let { as: declareAs = name } = decl;
        if (this.declareAs) {
            declareAs = `${this.declareAs}/${declareAs}`;
        }
        if (declareAs) {
            // Nested entry name.
            return new ModuleInfo(this.source, declareAs, {
                file: (_a = decl.file) !== null && _a !== void 0 ? _a : this.file,
                libs: referredLibs(this.source, decl.lib, this._libs),
                refs: (_b = decl.refs) !== null && _b !== void 0 ? _b : this.refs,
            });
        }
        return this;
    }
    pathTo({ file: to }) {
        const from = this.file;
        if (!from || !to || from === to) {
            return;
        }
        const relativePath = path.relative(path.dirname(from), to);
        return relativePath.split(path.sep).map(encodeURIComponent).join(path.sep);
    }
}
async function packageName() {
    const packageJson = await promises.readFile('package.json', { encoding: 'utf-8' });
    const { name } = JSON.parse(packageJson);
    if (!name) {
        throw new Error('Can not detect module name automatically. '
            + "Consider to set `flatDts({ moduleName: '<MODULE>' })` option explicitly");
    }
    return name;
}
function referredLibs(source, lib, defaultLibs = noReferredLibs) {
    if (lib === true) {
        lib = source.setup.compilerOptions.lib;
    }
    if (lib == null) {
        return defaultLibs;
    }
    const result = new Set();
    if (typeof lib === 'string') {
        result.add(referredLib(lib));
    }
    else if (lib !== false) {
        for (const name of lib) {
            result.add(referredLib(name));
        }
    }
    return result;
}
function referredLib(name) {
    return name.endsWith('.d.ts') && name.startsWith('lib.') ? name.slice(4, -5) : name;
}

function moduleMatcher(patterns) {
    const globs = patternsToGlobs(patterns);
    if (!globs.length) {
        return _name => false;
    }
    return name => micromatch.isMatch(name, globs, { dot: true });
}
function patternsToGlobs(patterns) {
    return patterns
        ? Array.isArray(patterns)
            ? patterns.map(patternToGlob)
            : [patternToGlob(patterns)]
        : [];
}
function patternToGlob(pattern) {
    return isGlob(pattern, { strict: false }) ? pattern : `${pattern}/**`;
}

class ModuleIndex {
    constructor(_source) {
        this._source = _source;
        this._byName = new Map();
        const { source, setup: { dtsOptions }, } = _source;
        const { entries = {} } = dtsOptions;
        this._meta = new DtsMeta(source);
        const names = [];
        const declarations = new Map();
        for (const [name, decl] of Object.entries(entries)) {
            if (decl) {
                declarations.set(name, decl);
                names.push(name);
            }
        }
        // Longest first.
        names.sort((first, second) => second.length - first.length);
        this._names = names;
        this._declarations = declarations;
        this._isInternal = moduleMatcher(dtsOptions.internal);
        this._isExternal = moduleMatcher(dtsOptions.external);
    }
    byName(name) {
        const found = this._byName.get(name);
        if (found) {
            // Already cached.
            return found;
        }
        if (this._isExternal(name)) {
            // External module.
            return this._put(name, ModuleInfo.external(this._source, name));
        }
        if (this._isInternal(name)) {
            // External module.
            return this._put(name, ModuleInfo.internal(this._source, name));
        }
        const decl = this._declarations.get(name);
        if (decl) {
            // Entry declared.
            return this._put(name, this.main().then(main => main.nested(name, decl)));
        }
        if (!this._meta.isModuleDeclared(name)) {
            // No such module declaration in `.d.ts` file.
            // Mark it external.
            return this._put(name, ModuleInfo.external(this._source, name));
        }
        const matchingName = this._names.find(n => n === name || name.startsWith(n + '/'));
        if (matchingName) {
            // Use matching module.
            return this._put(name, this.byName(matchingName));
        }
        // No matching module found.
        // Return the main entry.
        return this.main();
    }
    main() {
        const main = ModuleInfo.main(this._source);
        return (this.main = () => main)();
    }
    _put(name, info) {
        const result = Promise.resolve(info);
        this._byName.set(name, result);
        return result;
    }
}

const NONE_TRANSFORMED = { to: [] };
function noneTransformed() {
    return NONE_TRANSFORMED;
}
async function allTransformed(transformed) {
    const list = await Promise.all(transformed);
    return list.reduce(({ to: all, dia: fullDia, refs: allRefs }, { to, dia, refs }) => ({
        to: [...all, ...to],
        dia: dia ? (fullDia ? [...fullDia, ...dia] : dia) : fullDia,
        refs: refs ? (allRefs ? [...allRefs, ...refs] : refs) : allRefs,
    }), noneTransformed());
}

class DtsTransformer {
    constructor(_source) {
        this._source = _source;
        this._index = new ModuleIndex(_source);
    }
    async transform(initialDiagnostics) {
        const topLevel = await this._transform();
        const diagnostics = initialDiagnostics.slice();
        const files = this._emitFiles(topLevel, diagnostics);
        return createFlatDts(files, diagnostics);
    }
    _emitFiles(statements, diagnostics) {
        const contentByPath = new Map();
        for (const { to: topLevel, dia, refs } of statements) {
            if (dia) {
                diagnostics.push(...dia);
            }
            for (const [info, statement] of topLevel) {
                if (info.file) {
                    const key = resolve(info.file);
                    let dtsContent = contentByPath.get(key);
                    if (!dtsContent) {
                        dtsContent = new DtsContent(this._source, info);
                        contentByPath.set(key, dtsContent);
                    }
                    dtsContent.refer(refs).append(statement);
                }
            }
        }
        return [...contentByPath.values()].flatMap(content => content.toFiles());
    }
    async _transform() {
        return Promise.all(this._source.source.statements.map(statement => this._topLevel(statement)));
    }
    async _topLevel(statement) {
        if (statement.kind === ts.SyntaxKind.ModuleDeclaration) {
            return this._topLevelModuleDecl(statement);
        }
        return { to: [[await this._index.main(), statement]] };
    }
    async _topLevelModuleDecl(decl) {
        if (ts.isMemberName(decl.name)) {
            return { to: [[await this._index.main(), decl]] };
        }
        const moduleName = decl.name.text;
        const target = await this._index.byName(moduleName);
        if (target.isExternal) {
            // External module remains as is.
            return { to: [[await this._index.main(), decl]] };
        }
        if (target.isInternal) {
            // Remove internal module declarations.
            return noneTransformed();
        }
        // Rename the module.
        const { to: [body], dia, refs, } = await this._moduleBody(target, decl);
        return {
            to: body
                ? [
                    [
                        target,
                        ts.factory.updateModuleDeclaration(decl, decl.modifiers, ts.factory.createStringLiteral(target.declareAs), body),
                    ],
                ]
                : [],
            dia,
            refs,
        };
    }
    async _moduleBody(enclosing, decl) {
        const { body } = decl;
        if (!isBodyBlock(body)) {
            return noneTransformed();
        }
        const { to: statements, dia, refs, } = await allTransformed(body.statements.map(statement => this._statement(enclosing, statement)));
        if (!statements.length) {
            return noneTransformed();
        }
        return {
            to: [ts.factory.updateModuleBlock(body, statements)],
            dia,
            refs,
        };
    }
    async _statement(enclosing, statement) {
        switch (statement.kind) {
            case ts.SyntaxKind.ImportDeclaration:
                return this._import(enclosing, statement);
            case ts.SyntaxKind.ExportDeclaration:
                return this._export(enclosing, statement);
            case ts.SyntaxKind.ModuleDeclaration:
                return this._innerModuleDecl(enclosing, statement);
            default:
                return { to: [statement] };
        }
    }
    async _import(enclosing, statement) {
        const { moduleSpecifier } = statement;
        if (moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {
            // Invalid syntax?
            return { to: [statement] };
        }
        const { text: from } = moduleSpecifier;
        const fromModule = await this._index.byName(from);
        if (fromModule.declareAs !== enclosing.declareAs) {
            // Import from another module.
            if (fromModule.isInternal) {
                // Drop import from internal module.
                return noneTransformed();
            }
            // Replace module reference.
            return {
                to: [
                    ts.factory.updateImportDeclaration(statement, statement.modifiers, statement.importClause, ts.factory.createStringLiteral(fromModule.declareAs), statement.assertClause),
                ],
                refs: [fromModule],
            };
        }
        // Import from the same module.
        const { importClause } = statement;
        if (!importClause) {
            // No import clause. Remove the import.
            return noneTransformed();
        }
        const { name } = importClause;
        let { namedBindings } = importClause;
        if (namedBindings && namedBindings.kind === ts.SyntaxKind.NamedImports) {
            // Preserve aliased imports only.
            const elements = namedBindings.elements.filter(spec => !!spec.propertyName);
            if (elements.length) {
                namedBindings = ts.factory.updateNamedImports(namedBindings, elements);
            }
            else {
                namedBindings = undefined;
            }
        }
        if (!name && !namedBindings) {
            // No need in import statement.
            return noneTransformed();
        }
        return {
            to: [
                ts.factory.updateImportDeclaration(statement, statement.modifiers, ts.factory.updateImportClause(importClause, importClause.isTypeOnly, name, namedBindings), ts.factory.createStringLiteral(enclosing.declareAs), statement.assertClause),
            ],
            dia: name ? [this._diagnostics(statement, 'Unsupported default import')] : undefined,
        };
    }
    async _export(enclosing, statement) {
        const { moduleSpecifier } = statement;
        if (!moduleSpecifier) {
            // No module specifier.
            // The export remains as is.
            return { to: [statement] };
        }
        if (moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {
            // Invalid syntax?
            return { to: [statement] };
        }
        const { text: from } = moduleSpecifier;
        const fromModule = await this._index.byName(from);
        if (fromModule.declareAs !== enclosing.declareAs) {
            // Export from another module.
            if (fromModule.isInternal) {
                // Drop export from internal module.
                return noneTransformed();
            }
            // Replace module reference.
            return {
                to: [
                    ts.factory.updateExportDeclaration(statement, statement.modifiers, statement.isTypeOnly, statement.exportClause, ts.factory.createStringLiteral(fromModule.declareAs), statement.assertClause),
                ],
                refs: [fromModule],
            };
        }
        // Export from the same module.
        const { exportClause } = statement;
        if (!exportClause) {
            // No need to re-export.
            return noneTransformed();
        }
        if (exportClause.kind === ts.SyntaxKind.NamedExports) {
            // Preserve aliased exports only.
            const elements = exportClause.elements.filter(spec => !!spec.propertyName);
            if (!elements.length) {
                return noneTransformed();
            }
            return {
                to: [
                    ts.factory.updateExportDeclaration(statement, statement.modifiers, statement.isTypeOnly, ts.factory.updateNamedExports(exportClause, elements), undefined, statement.assertClause),
                ],
            };
        }
        // Namespace export.
        // Remains as is, but this would break the `.d.ts`.
        return {
            to: [statement],
            dia: [this._diagnostics(statement, 'Unsupported default export')],
        };
    }
    async _innerModuleDecl(enclosing, decl) {
        if (ts.isMemberName(decl.name)) {
            return { to: [decl] };
        }
        const moduleName = decl.name.text;
        const target = await this._index.byName(moduleName);
        if (target.isExternal) {
            return { to: [decl] };
        }
        if (target.isInternal) {
            return noneTransformed();
        }
        if (target === enclosing) {
            // No need to re-declare the module within itself.
            const { body } = decl;
            if (!isBodyBlock(body)) {
                return noneTransformed();
            }
            // Expand module body.
            return allTransformed(body.statements.map(statement => this._statement(enclosing, statement)));
        }
        // Rename the module.
        const { to: [body], dia, refs, } = await this._moduleBody(target, decl);
        return {
            to: body
                ? [
                    ts.factory.updateModuleDeclaration(decl, decl.modifiers, ts.factory.createStringLiteral(target.declareAs), body),
                ]
                : [],
            dia,
            refs,
        };
    }
    _diagnostics(node, messageText) {
        const { source } = this._source;
        const start = node.getStart(source);
        const end = node.getEnd();
        return {
            category: ts.DiagnosticCategory.Error,
            code: 9999,
            file: source,
            start: start,
            length: end - start,
            messageText,
        };
    }
}
function isBodyBlock(body) {
    return !!body && ts.isModuleBlock(body);
}

/**
 * Emits flat type definitions.
 *
 * Does not actually writes to `.d.ts` files.
 *
 * @param dtsOptions - Flattening options.
 *
 * @returns A promise resolved to flattened type definitions representation.
 */
async function emitFlatDts(dtsOptions = {}) {
    const setup = new DtsSetup(dtsOptions);
    const { compilerOptions, files, errors } = setup;
    const program = ts.createProgram({
        rootNames: files,
        options: compilerOptions,
        host: ts.createCompilerHost(compilerOptions, true),
        configFileParsingDiagnostics: errors,
    });
    const { sources, diagnostics } = await new Promise(resolve => {
        const sources = [];
        try {
            const { diagnostics } = program.emit(undefined /* all source files */, (path, content) => {
                sources.push({ path, content });
            }, undefined /* cancellationToken */, true /* emitOnlyDtsFiles */);
            resolve({ sources, diagnostics });
        }
        catch (error) {
            resolve({
                sources,
                diagnostics: [
                    {
                        category: ts.DiagnosticCategory.Error,
                        code: 9999,
                        file: undefined,
                        start: undefined,
                        length: undefined,
                        messageText: error instanceof Error ? error.message : String(error),
                    },
                ],
            });
        }
    });
    const source = await DtsSource.create(sources, setup);
    if (!source) {
        return emptyFlatDts(diagnostics);
    }
    try {
        const transformer = new DtsTransformer(source);
        return transformer.transform(diagnostics);
    }
    finally {
        source.destroy();
    }
}

export { emitFlatDts };
//# sourceMappingURL=flat-dts.api.js.map
